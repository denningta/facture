/******************************************************************************
 * This file was generated by langium-cli 1.0.0.
 * DO NOT EDIT MANUALLY!
 ******************************************************************************/

/* eslint-disable */
import { AstNode, AbstractAstReflection, Reference, ReferenceInfo, TypeMetaData } from 'langium';

export type AbstractElement = GenericObject | IntegerType | ObjectRef | StringType;

export const AbstractElement = 'AbstractElement';

export function isAbstractElement(item: unknown): item is AbstractElement {
    return reflection.isInstance(item, AbstractElement);
}

export type AbstractType = GenericObject | Interface;

export const AbstractType = 'AbstractType';

export function isAbstractType(item: unknown): item is AbstractType {
    return reflection.isInstance(item, AbstractType);
}

export type FeatureName = string;

export type PrimitiveType = 'boolean' | 'number' | 'string';

export interface AtomType extends AstNode {
    readonly $container: TypeAttribute;
    readonly $type: 'AtomType';
    isArray: boolean
    keywordType?: Keyword
    primitiveType?: PrimitiveType
    refType?: Reference<AbstractType>
}

export const AtomType = 'AtomType';

export function isAtomType(item: unknown): item is AtomType {
    return reflection.isInstance(item, AtomType);
}

export interface GenericObject extends AstNode {
    readonly $container: Model | Property | PropertyArray;
    readonly $type: 'GenericObject';
    interface: Reference<Interface>
    name: string
    properties: Array<Property | PropertyArray>
}

export const GenericObject = 'GenericObject';

export function isGenericObject(item: unknown): item is GenericObject {
    return reflection.isInstance(item, GenericObject);
}

export interface IntegerType extends AstNode {
    readonly $container: Model | Property | PropertyArray;
    readonly $type: 'IntegerType';
    data: number
}

export const IntegerType = 'IntegerType';

export function isIntegerType(item: unknown): item is IntegerType {
    return reflection.isInstance(item, IntegerType);
}

export interface Interface extends AstNode {
    readonly $container: Model | Property | PropertyArray;
    readonly $type: 'Interface';
    attributes: Array<TypeAttribute>
    name: string
}

export const Interface = 'Interface';

export function isInterface(item: unknown): item is Interface {
    return reflection.isInstance(item, Interface);
}

export interface Keyword extends AstNode {
    readonly $container: AtomType;
    readonly $type: 'Keyword';
    value: string
}

export const Keyword = 'Keyword';

export function isKeyword(item: unknown): item is Keyword {
    return reflection.isInstance(item, Keyword);
}

export interface Model extends AstNode {
    readonly $type: 'Model';
    interfaces: Array<Interface>
    objects: Array<GenericObject>
}

export const Model = 'Model';

export function isModel(item: unknown): item is Model {
    return reflection.isInstance(item, Model);
}

export interface ObjectRef extends AstNode {
    readonly $container: Model | Property | PropertyArray;
    readonly $type: 'ObjectRef';
    data: Reference<GenericObject>
}

export const ObjectRef = 'ObjectRef';

export function isObjectRef(item: unknown): item is ObjectRef {
    return reflection.isInstance(item, ObjectRef);
}

export interface Property extends AstNode {
    readonly $container: GenericObject;
    readonly $type: 'Property';
    name: FeatureName
    value: AbstractElement
}

export const Property = 'Property';

export function isProperty(item: unknown): item is Property {
    return reflection.isInstance(item, Property);
}

export interface PropertyArray extends AstNode {
    readonly $container: GenericObject;
    readonly $type: 'PropertyArray';
    name: FeatureName
    value: Array<AbstractElement>
}

export const PropertyArray = 'PropertyArray';

export function isPropertyArray(item: unknown): item is PropertyArray {
    return reflection.isInstance(item, PropertyArray);
}

export interface StringType extends AstNode {
    readonly $container: Model | Property | PropertyArray;
    readonly $type: 'StringType';
    data: string
}

export const StringType = 'StringType';

export function isStringType(item: unknown): item is StringType {
    return reflection.isInstance(item, StringType);
}

export interface TypeAttribute extends AstNode {
    readonly $container: Interface;
    readonly $type: 'TypeAttribute';
    isOptional: boolean
    name: FeatureName
    typeAlternatives: Array<AtomType>
}

export const TypeAttribute = 'TypeAttribute';

export function isTypeAttribute(item: unknown): item is TypeAttribute {
    return reflection.isInstance(item, TypeAttribute);
}

export interface FactureAstType {
    AbstractElement: AbstractElement
    AbstractType: AbstractType
    AtomType: AtomType
    GenericObject: GenericObject
    IntegerType: IntegerType
    Interface: Interface
    Keyword: Keyword
    Model: Model
    ObjectRef: ObjectRef
    Property: Property
    PropertyArray: PropertyArray
    StringType: StringType
    TypeAttribute: TypeAttribute
}

export class FactureAstReflection extends AbstractAstReflection {

    getAllTypes(): string[] {
        return ['AbstractElement', 'AbstractType', 'AtomType', 'GenericObject', 'IntegerType', 'Interface', 'Keyword', 'Model', 'ObjectRef', 'Property', 'PropertyArray', 'StringType', 'TypeAttribute'];
    }

    protected override computeIsSubtype(subtype: string, supertype: string): boolean {
        switch (subtype) {
            case GenericObject: {
                return this.isSubtype(AbstractElement, supertype) || this.isSubtype(AbstractType, supertype);
            }
            case IntegerType:
            case ObjectRef:
            case StringType: {
                return this.isSubtype(AbstractElement, supertype);
            }
            case Interface: {
                return this.isSubtype(AbstractType, supertype);
            }
            default: {
                return false;
            }
        }
    }

    getReferenceType(refInfo: ReferenceInfo): string {
        const referenceId = `${refInfo.container.$type}:${refInfo.property}`;
        switch (referenceId) {
            case 'AtomType:refType': {
                return AbstractType;
            }
            case 'GenericObject:interface': {
                return Interface;
            }
            case 'ObjectRef:data': {
                return GenericObject;
            }
            default: {
                throw new Error(`${referenceId} is not a valid reference id.`);
            }
        }
    }

    getTypeMetaData(type: string): TypeMetaData {
        switch (type) {
            case 'AtomType': {
                return {
                    name: 'AtomType',
                    mandatory: [
                        { name: 'isArray', type: 'boolean' }
                    ]
                };
            }
            case 'GenericObject': {
                return {
                    name: 'GenericObject',
                    mandatory: [
                        { name: 'properties', type: 'array' }
                    ]
                };
            }
            case 'Interface': {
                return {
                    name: 'Interface',
                    mandatory: [
                        { name: 'attributes', type: 'array' }
                    ]
                };
            }
            case 'Model': {
                return {
                    name: 'Model',
                    mandatory: [
                        { name: 'interfaces', type: 'array' },
                        { name: 'objects', type: 'array' }
                    ]
                };
            }
            case 'PropertyArray': {
                return {
                    name: 'PropertyArray',
                    mandatory: [
                        { name: 'value', type: 'array' }
                    ]
                };
            }
            case 'TypeAttribute': {
                return {
                    name: 'TypeAttribute',
                    mandatory: [
                        { name: 'isOptional', type: 'boolean' },
                        { name: 'typeAlternatives', type: 'array' }
                    ]
                };
            }
            default: {
                return {
                    name: type,
                    mandatory: []
                };
            }
        }
    }
}

export const reflection = new FactureAstReflection();
