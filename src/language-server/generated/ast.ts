/******************************************************************************
 * This file was generated by langium-cli 1.0.0.
 * DO NOT EDIT MANUALLY!
 ******************************************************************************/

/* eslint-disable */
import { AstNode, AbstractAstReflection, Reference, ReferenceInfo, TypeMetaData } from 'langium';

export type FeatureName = string;

export type PrimitiveType = 'Date' | 'bigint' | 'boolean' | 'number' | 'string';

export interface AtomType extends AstNode {
    readonly $container: TypeAttribute;
    readonly $type: 'AtomType';
    isArray: boolean
    isDefinition: boolean
    keywordType?: Keyword
    primitiveType?: PrimitiveType
    refType?: Reference<Interface>
}

export const AtomType = 'AtomType';

export function isAtomType(item: unknown): item is AtomType {
    return reflection.isInstance(item, AtomType);
}

export interface GenericObject extends AstNode {
    readonly $container: Model | ObjectDef;
    readonly $type: 'GenericObject';
    interface: Reference<Interface>
    name: string
    properties: Array<Property>
}

export const GenericObject = 'GenericObject';

export function isGenericObject(item: unknown): item is GenericObject {
    return reflection.isInstance(item, GenericObject);
}

export interface Interface extends AstNode {
    readonly $container: Model;
    readonly $type: 'Interface';
    attributes: Array<TypeAttribute>
    name: string
}

export const Interface = 'Interface';

export function isInterface(item: unknown): item is Interface {
    return reflection.isInstance(item, Interface);
}

export interface Keyword extends AstNode {
    readonly $container: AtomType;
    readonly $type: 'Keyword';
    value: string
}

export const Keyword = 'Keyword';

export function isKeyword(item: unknown): item is Keyword {
    return reflection.isInstance(item, Keyword);
}

export interface Model extends AstNode {
    readonly $type: 'Model';
    interfaces: Array<Interface>
    objects: Array<GenericObject>
}

export const Model = 'Model';

export function isModel(item: unknown): item is Model {
    return reflection.isInstance(item, Model);
}

export interface ObjectArrayRef extends AstNode {
    readonly $container: Property;
    readonly $type: 'ObjectArrayRef';
    objects: Array<Reference<GenericObject>>
}

export const ObjectArrayRef = 'ObjectArrayRef';

export function isObjectArrayRef(item: unknown): item is ObjectArrayRef {
    return reflection.isInstance(item, ObjectArrayRef);
}

export interface ObjectDef extends AstNode {
    readonly $container: Property;
    readonly $type: 'ObjectDef';
    objects: Array<GenericObject>
    type: 'ObjectDef'
}

export const ObjectDef = 'ObjectDef';

export function isObjectDef(item: unknown): item is ObjectDef {
    return reflection.isInstance(item, ObjectDef);
}

export interface ObjectRef extends AstNode {
    readonly $container: Property;
    readonly $type: 'ObjectRef';
    object: Reference<GenericObject>
}

export const ObjectRef = 'ObjectRef';

export function isObjectRef(item: unknown): item is ObjectRef {
    return reflection.isInstance(item, ObjectRef);
}

export interface Property extends AstNode {
    readonly $container: GenericObject;
    readonly $type: 'Property';
    name: FeatureName
    value: ObjectArrayRef | ObjectDef | ObjectRef | StringValue
}

export const Property = 'Property';

export function isProperty(item: unknown): item is Property {
    return reflection.isInstance(item, Property);
}

export interface StringValue extends AstNode {
    readonly $container: Property;
    readonly $type: 'StringValue';
    string: string
}

export const StringValue = 'StringValue';

export function isStringValue(item: unknown): item is StringValue {
    return reflection.isInstance(item, StringValue);
}

export interface TypeAttribute extends AstNode {
    readonly $container: Interface;
    readonly $type: 'TypeAttribute';
    isOptional: boolean
    name: FeatureName
    typeAlternatives: Array<AtomType>
}

export const TypeAttribute = 'TypeAttribute';

export function isTypeAttribute(item: unknown): item is TypeAttribute {
    return reflection.isInstance(item, TypeAttribute);
}

export interface FactureAstType {
    AtomType: AtomType
    GenericObject: GenericObject
    Interface: Interface
    Keyword: Keyword
    Model: Model
    ObjectArrayRef: ObjectArrayRef
    ObjectDef: ObjectDef
    ObjectRef: ObjectRef
    Property: Property
    StringValue: StringValue
    TypeAttribute: TypeAttribute
}

export class FactureAstReflection extends AbstractAstReflection {

    getAllTypes(): string[] {
        return ['AtomType', 'GenericObject', 'Interface', 'Keyword', 'Model', 'ObjectArrayRef', 'ObjectDef', 'ObjectRef', 'Property', 'StringValue', 'TypeAttribute'];
    }

    protected override computeIsSubtype(subtype: string, supertype: string): boolean {
        switch (subtype) {
            default: {
                return false;
            }
        }
    }

    getReferenceType(refInfo: ReferenceInfo): string {
        const referenceId = `${refInfo.container.$type}:${refInfo.property}`;
        switch (referenceId) {
            case 'AtomType:refType':
            case 'GenericObject:interface': {
                return Interface;
            }
            case 'ObjectArrayRef:objects':
            case 'ObjectRef:object': {
                return GenericObject;
            }
            default: {
                throw new Error(`${referenceId} is not a valid reference id.`);
            }
        }
    }

    getTypeMetaData(type: string): TypeMetaData {
        switch (type) {
            case 'AtomType': {
                return {
                    name: 'AtomType',
                    mandatory: [
                        { name: 'isArray', type: 'boolean' },
                        { name: 'isDefinition', type: 'boolean' }
                    ]
                };
            }
            case 'GenericObject': {
                return {
                    name: 'GenericObject',
                    mandatory: [
                        { name: 'properties', type: 'array' }
                    ]
                };
            }
            case 'Interface': {
                return {
                    name: 'Interface',
                    mandatory: [
                        { name: 'attributes', type: 'array' }
                    ]
                };
            }
            case 'Model': {
                return {
                    name: 'Model',
                    mandatory: [
                        { name: 'interfaces', type: 'array' },
                        { name: 'objects', type: 'array' }
                    ]
                };
            }
            case 'ObjectArrayRef': {
                return {
                    name: 'ObjectArrayRef',
                    mandatory: [
                        { name: 'objects', type: 'array' }
                    ]
                };
            }
            case 'ObjectDef': {
                return {
                    name: 'ObjectDef',
                    mandatory: [
                        { name: 'objects', type: 'array' }
                    ]
                };
            }
            case 'TypeAttribute': {
                return {
                    name: 'TypeAttribute',
                    mandatory: [
                        { name: 'isOptional', type: 'boolean' },
                        { name: 'typeAlternatives', type: 'array' }
                    ]
                };
            }
            default: {
                return {
                    name: type,
                    mandatory: []
                };
            }
        }
    }
}

export const reflection = new FactureAstReflection();
